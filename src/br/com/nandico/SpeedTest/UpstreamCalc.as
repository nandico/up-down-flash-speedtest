package br.com.nandico.SpeedTest{	public class UpstreamCalc	{		private var packages:Array;				public var uploadingPackageCount:Number = 0;		public var errorPackageCount:Number = 0;		public var finishedPackageCount:Number = 0;		public var idlePackageCount:Number = 0;		private var _bytesTotal:Number = 0;		private var _bytesLoaded:Number = 0;		private var _percentLoaded:Number = 0;			public function UpstreamCalc(packages:Array)		{			this.packages = packages;						updatePackageCount();		}				private function updatePackageCount():void		{			var packageLength:uint = packages.length;			var upstreamPackage:UpstreamPackageModel = null;						uploadingPackageCount = errorPackageCount = finishedPackageCount = idlePackageCount = 0;						for(var i:uint = 0; i < packageLength; i++)			{				upstreamPackage = packages[i];					if(upstreamPackage.status == UpstreamPackageModel.STATUS_UPLOADING) uploadingPackageCount++;				if(upstreamPackage.status == UpstreamPackageModel.STATUS_ERROR) errorPackageCount++;				if(upstreamPackage.status == UpstreamPackageModel.STATUS_FINISHED) finishedPackageCount++;				if(upstreamPackage.status == UpstreamPackageModel.STATUS_IDLE) idlePackageCount++;							}		}				private function updateByteMetrics():void		{			var packageLength:uint = packages.length;			var upstreamPackage:UpstreamPackageModel = null;						_bytesTotal = _bytesLoaded = _percentLoaded = 0;						for(var i:uint = 0; i < packageLength; i++)			{				upstreamPackage = packages[i];					if(upstreamPackage.status == UpstreamPackageModel.STATUS_IDLE) continue;								_bytesTotal += upstreamPackage.bytesTotal;				_bytesLoaded += upstreamPackage.bytesLoaded;				_percentLoaded = Math.round((upstreamPackage.bytesLoaded / upstreamPackage.bytesTotal) * 100)			}		}						public function get bytesTotal():Number		{			updateByteMetrics();			return _bytesTotal;		}				public function get bytesLoaded():Number		{			updateByteMetrics();			return _bytesLoaded;		}				public function get percentLoaded():Number		{			updateByteMetrics();			return _percentLoaded;		}				public function getOverallPercentLoaded():Number		{			var packageLength:uint = packages.length;			var upstreamPackage:UpstreamPackageModel = null;						var overallPercentLoaded:Number = 0;						for(var i:uint = 0; i < packageLength; i++)			{				upstreamPackage = packages[i];					if(upstreamPackage.status == UpstreamPackageModel.STATUS_IDLE) continue;								overallPercentLoaded += Math.round((upstreamPackage.bytesLoaded / upstreamPackage.bytesTotal) * 100)			}						return overallPercentLoaded / packageLength;		}				public function getStatus():String		{			updatePackageCount();						if(finishedPackageCount == packages.length)			{				return "Upstream test finished without errors.";			}			else if(errorPackageCount > 0)			{				return "Error in one or more upstream packages.";			}			else			{				return "Upstream test in progress.";			}		}				public function getInstantKbps():Number		{			var packageLength:uint = packages.length;			var upstreamPackage:UpstreamPackageModel = null;						var packageLife:Number = 0;			var packageBytes:Number = 0;						var validIterations:Number = 0;			var overallSpeed:Number = 0;						for(var i:uint = 0; i < packageLength; i++)			{				upstreamPackage = packages[i];				packageLife = 0;					if(upstreamPackage.status == UpstreamPackageModel.STATUS_IDLE || 				   upstreamPackage.status == UpstreamPackageModel.STATUS_ERROR) continue;								if(upstreamPackage.status == UpstreamPackageModel.STATUS_UPLOADING)				{					packageLife = (new Date()).valueOf() - upstreamPackage.birthDate.valueOf();					packageBytes = upstreamPackage.desiredBytes;				}				else				{					packageLife = upstreamPackage.deathDate.valueOf() - upstreamPackage.birthDate.valueOf();					packageBytes = upstreamPackage.desiredBytes;				}								//				|     - to kb -     		  |   |    - to secs -    |				overallSpeed += ( ( packageBytes * 8 ) / 1024 ) / ( packageLife / 1000 );				validIterations ++;			}						return overallSpeed / validIterations;		}	}}